# 《Linux内核设计与实现》总结

## 0x01 读后感

大约花了两周时间以每天30页的速度读完了这本书，做这篇总结时又二刷了一遍。这也是最近自己在业余时间第一本完整看完的、具有相当分量的专业书。

本书主要对Linux内核涉及的进程（进程管理、进程调度、内核同步）、系统调用、中断（中断和中断处理、下半部和推后执行的工作）、定时器、内存（物理内存管理、进程地址空间）、磁盘（虚拟文件系统、块IO层、页高速缓存和页回写）分别进行了详细讲解，非常通俗易懂。

收获：

通过本书，基本搞懂了Linux内核的组成以及各个模块的实现过程，尤其是以前一点也不熟悉的中断机制和下半部，让自己对中断的理解有了质的飞跃。

不足：

读完后，对文件系统和内存管理还是糊里糊涂的，这部分需要自己再找一些资料看看。另外书中没有提及计算机加电启动后是如何一步步加载系统的，这一点感觉对初学者学习操作系统来说，应该是提纲挈领的作用。

等到知识储备到位时，尝试写一个《Linux内核导读手册》的系列专题，尽量在讨论如何做的基础上，深入讨论为什么要这么做。把从启动到整个操作系统各个模块的运行全部串起来讲一遍，肯定很有效果。

## 0x02 摘录

### 第1-2、6章：Linux内核简介

#### 1. 内核的组成

**通常一个内核由负责响应中断的中断服务程序，负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序和网络、进程间通信等系统服务程序共同组成。**

CPU在任一时刻只有两种状态：进程上下文（运行在用户空间或运行在内核空间）和中断上下文。当CPU空闲时，内核就运行一个idle空进程，处于进程上下文，运行在内核空间。

Linux是单内核，但支持动态加载内核模块，支持对称多处理SMP机制，支持抢占式。内核对抢占式、对称多处理器SMP、中断三者之间同步和并发的复杂处理。

#### 2. 宏和内联函数

宏是由预处理器对宏进行简单的文本替换，而内联函数是在编译期间被嵌入到目标代码中。

宏没有类型检查，可能传进来任意类型，在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。内联函数inline可以进行诸如类型安全检查、语句是否正确等编译功能，不会出现二义性。

#### 3. voatile关键字

C编译器通常只将变量装载一次。一般情况下不能保证循环中的jiffies变量在每次循环被读取时都能被重新载入。但我们又要求jiffies在每次循环时都必须重新装载，因为在后台jiffies值会随着时钟中断的发生而不断增加。

为了解决这个问题，jiffies变量被标记为关键字volatile。关键字voatile指示编译器在每次访问变量时都重新从主内存中获得，而不是通过寄存器中的变量别名来访问，从而确保前面的循环能按预期的方式执行。

#### 4. 数据结构：链表

Linux内核的标准链表就是采用环形双向链表形式实现的。

```
struct list_head{
    struct list_head *next;
    struct list_head *prev;
};
```

使用宏container_of可以很方便地从链表指针找到父结构中包含的任何变量，这是因为在C语言中，一个给定结构中的变量偏移在编译时地址就被ABI固定下来了。

使用container_of宏，我们定义一个简单的函数便可返回包含list_head的父类型结构体的宏list_entry。

遍历链表最简单的方法是使用list_for_each宏。大多数内核代码采用list_for_each_entry宏遍历链表，返回list_head所在父结构体的指针。

很多原因会需要反向遍历链表。其中一个是性能原因：如果你知道要寻找的节点最可能在你搜索起始节点的前面，那么反向搜索岂不是更快。第二个原因是：如果顺序很重要，比如如果你使用链表实现堆栈，那么你需要从尾部向前遍历才能达到后进先出的原则。

#### 5. 数据结构：二叉树

一个二叉搜索树所有节点必然都有序，且左子节点小于其父节点值，而右子节点大于其父节点值的二叉树。

一个平衡二叉搜索树是一个所有叶子节点深度差不超过1的二叉搜索树。一个自平衡二叉搜索树是指其所有操作都试图维持平衡的二叉搜索树。

红黑树是一种自平衡二叉搜索树。红黑树的插入和删除都需要维持平衡的约束。

#### 6. 数据结构选择

没有数据结构可以提供比线性算法复杂度更好的算法来遍历元素，所以你应该用最简单的数据结构完成简单的工作。

如果你需要存储大量数据并且检索迅速，那么红黑树最好。红黑树可以确保搜索时间复杂度是对数关系，同时也能保证按序遍历时间复杂度是线性关系。

### 第3-4章：进程管理

#### 1. 进程描述符

进程提供两种虚拟机制，虚拟处理器和虚拟内存。对于Linux而言，线程只不过是一种特殊的进程。线程之间可以共享虚拟内存，但每个线程都拥有各自的虚拟处理器。

内核把进程存放在叫做任务队列的双向循环列表中，链表中的每一项都是类型为task_struct、称为进程描述符的结构体。Linux通过slab分配器分配task_struct结构，这样能达到对象复用和缓存着色的目的。

slab分配器：通过预先分配和重复使用task_struct，可以避免动态分配和释放所带来的资源消耗。

#### 2. task_struct的存放位置

如果是寄存器较多的CPU体系架构中，可能使用一个单独的寄存器来存放task_struct的地址。比如PowerPC架构中使用r2寄存器保存task_struct地址。但对于x86这种寄存器较少的体系架构来说，单独占用一个寄存器不合适，因此就把它放在了栈上。

在slab分配器机制出现之前的低版本Linux内核中，整个task_struct结构体都是和内核栈放在一起的，二者大致是这样定义的：

```
union {
    struct task_struct task;
    unsigned long stack[KERNEL_STACK_SIZE/sizeof (unsigned long)];
}
```

task_struct和内核栈共同使用了一段4kb或8kb的内存。更确切地说，内核根本不给task_struct分配内存，而仅仅给内核栈分配8K的内存，并把其中的一部分给task_struct使用。task_struct结构大约占1K字节左右（不同版本稍有不同），因此内核栈的大小不能超过7K，否则内核栈会覆盖task_struct结构，从而导致内核崩溃。

出现slab之后的高版本中，task_struct就通过slab分配器动态生成，指针存放于thread_info结构体的task变量，而thread_info就和内核栈共用内存了，定义是这样的：

```
union thread_union {
#ifndef CONFIG_THREAD_INFO_IN_TASK
    struct thread_info thread_info;
#endif
    unsigned long stack[THREAD_SIZE/sizeof(long)];
};
```

thread_info结构体的task指针指向了task_struct的位置。

```
struct thread_info {
    ......
    struct task_struct *task;    /* main task structure */
    ......
};
```

在x86系统上，通过把栈指针esp的最后13位有效位屏蔽掉，即可得到thread_info的偏移，然后就可以找到task_struct的地址了。

#### 3. init进程

每个task_struct都包含一个指向其父进程task_struct、叫做parent的指针，还包含一个称为children的子进程链表。

Linux系统中所有的进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程。该进程读取系统的初始化脚本并执行其它相关程序，最终完成系统启动的整个过程。

init进程的进程描述符是作为init_task静态分配的。

#### 4. 写时拷贝

Unix的进程创建很特别。许多其它操作系统都提供了产生（spawn）进程的机制，首先在新的地址空间里创建进程，读入可执行文件，最后开始执行。Unix将上述步骤分解到两个单独的函数中去执行：fork和exec。fork通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅仅在于PID、PPID和某些资源统计量等。exec负责读取可执行文件并将其载入地址空间开始运行。

传统的fork系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下，因为它拷贝的数据也许并不共享，更糟糕的是，如果新进程打算立即执行一个新的映像，那么之前所有的拷贝都将前功尽弃。

因此Linux的fork采用写时拷贝copy-on-write页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术，内核一开始并不复制整个进程地址空间，而是让父进程和子进程共享一个拷贝。只有在需要写入的时候，数据才会被复制。这种技术使地址空间上的页拷贝被推迟到实际发生写入的时候才进行。

> 备注：父子进程共享的拷贝页起初是只读的，被修改时就会触发内存访问异常。异常处理程序就新建一块内存页分配给子进程使用。这就是写时拷贝。

fork最开始的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。一般进程创建后都会马上运行一个可执行的文件，因此这种优化可以避免拷贝大量根本就不会被使用的数据。

Linux通过clone系统调用实现fork。

#### 5. 线程

线程机制提供了在同一程序内共享内存地址空间运行的一组线程，这些线程还可以共享打开的文件和其它资源。线程机制支持并发程序设计技术，在多处理器上，它也能保证真正的并行处理。

Linux实现线程的机制非常独特，从内核的角度来说，它并没有线程这个概念。Linux把所有的线程都当作进程来实现。内核并没有准备特别的调度算法或是定义特别的数据结构来表示线程。线程仅仅被视为一个与其它进程共享某些资源的进程。每个线程都拥有唯一隶属于自己的task_struct。所以在内核中，它看起来就是一个普通的进程，只是线程和其它进程共享某些资源，比如地址空间。

线程通过调用clone时传递一些参数标志来指明需要共享的资源：地址空间、文件系统资源、文件描述符和信号处理程序等。

#### 6. 内核线程

内核经常需要在后台执行一些操作，这种任务可以通过内核线程完成——独立运行在内核空间的标准进程。内核线程和普通进程的区别在于内核线程没有独立的地址空间（指向地址空间的mm指针被设置为NULL）。它们只在内核空间运行，从来不切换到用户空间去。内核进程和普通进程一样，可以被调度，也可以被抢占。

#### 7. 调度程序

调度程序负责决定将哪个进程投入运行，何时运行以及运行多长时间。

- 抢占式多任务：由调度程序来决定什么时候停止一个进程的运行，以便其它进程能够得到执行机会。
- 非抢占式多任务：除非进程自己主动停止运行，否则它会一直执行。

完全公平调度CFS算法Completely Fair Scheduler。CFS调度器的抢占时机取决于新的可运行程序消耗了多少处理器使用比。如果消耗的使用比比当前进程小，则新进程立刻投入运行，抢占当前进程。否则，将推迟其运行。

调度策略决定调度程序在何时让什么进程运行。

#### 8. 时间片

时间片过长会导致系统对交互的响应表现欠佳，让人觉得系统无法并发执行应用程序；时间片太短会明显增大进程切换带来的处理器耗时，因为肯定会有相当一部分系统时间用在进程切换上。

因此任何长时间片都将导致系统交互表现欠佳。Linux的CFS调度器并没有直接分配时间片到进程，它是将处理器的使用比划分给了进程。CFS调度器，其抢占时机取决于新的可运行程序消耗了多少处理器使用比。如果消耗的使用比比当前进程小，则新进程立刻投入运行，抢占当前进程。否则，将推迟其运行。

所有的调度器都必须对进程运行时间记账。当每次系统时钟节拍发生时，时间片都会被减少一个节拍周期。当一个进程的时间片被减少到0时，它就会被另一个尚未减到0的时间片可运行进程抢占。

CFS调度算法的核心：选择具有最小vruntime的任务。红黑树算法。

虽然红黑树让我们可以很有效地找到最左叶子节点，但是更容易的做法时把最左叶子节点缓存起来。

#### 9. 什么时候调用schedule

内核必须知道在什么时候调用schedule。

如果仅靠用户程序代码显式地调用shcedule，它们可能就会永远地执行下去。相反，内核提供了一个need_resched标志来表明是否需要重新执行一次调度。

当某个进程应该被抢占时，schedule_tick就会设置这个标志；当一个优先级高的进程进入可执行状态的时候，try_to_wakeup也会设置这个标志，内核检查该标志，确认其被设置，调用schedule来切换到一个新的进程。

再返回用户空间以及从中断返回的时候，内核也会检查need_resched标志。

每个进程都包含一个need_resched标志，这是因为访问进程描述符的数值要比访问一个全局变量块。因为current宏速度很快并且描述符通常都在告诉缓存中。

内核无论是在中断处理程序还是在系统调用后返回，都会检查need_resched标志。

### 第5、7-8、9章：中断处理和下半部

#### 1. 中断上下文

当接收到一个中断后，中断控制器会给处理器发送一个电信号。处理器一经检测到此信号，便中断自己的当前工作转而处理中断。中断上下文也称作原子上下文，该上下文中的执行代码不可阻塞。

中断可能随时发生，因此中断处理程序也就随时可能执行。所以必须保证中断处理程序能够快速执行，这样才能保证尽可能快地恢复中断代码的执行。

#### 2.上半部与下半部

我们一般把中断处理切为两个部分或两半。许多操作系统都把处理硬件中断的过程分为两个部分：上半部分简单快速，执行的时候禁止一些或者全部中断。下半部分稍后执行，而且执行期间可以相应所有的中断。

中断处理程序是上半部top half：接收到一个中断，它就立即开始执行，但只做有严格时限的工作，例如对接收的中断进行应答或复位硬件，这些工作都是在所有中断被禁止的情况下完成的。能够被允许稍后完成的工作会推迟到下半部bottom half去。此后，在何时的时机，下半部会被开中断执行。

初始化硬件和注册中断处理程序的顺序必须正确，以防止中断处理程序在设备初始化完成之前就开始执行。

#### 3. 中断处理程序

即使其它什么工作也不做，绝大部分的中断处理程序至少需要知道产生中断的设备，告诉它已经收到中断了。对于复杂一些的设备，可能还需要在中断处理程序中发送和接收数据，以及执行一些扩充的工作。如前所述，应尽可能将扩充的工作推给下半部处理程序。

当一个给定的中断处理程序正在执行时，相应的中断线在所有处理器上都会被屏蔽掉，以防止在同一中断线上接收另一个新的中断。

#### 4. 中断处理机制的实现

中断从硬件到内核的路由。

设备产生中断，通过总线把电信号发送给中断控制器。如果中断线是激活的（它们是允许被屏蔽的），那么中断控制器就会把中断发往处理器。

除非在处理器上禁止该终端，否则处理器会立即停止执行它正在做的事，关闭中断系统，然后跳到内存中预定义的位置也就是中断处理程序入口点，开始执行那里的代码。

cli和sti分别是clear和set允许中断标志的汇编调用。

#### 5. 下半部：软中断

软中断是一组静态定义的下半部接口，有32个，可以在所有处理器上同时执行，即使两个类型相同也可以。

软中断保留给系统中对时间要求最严格以及最重要的下半部使用。目前，只有两个子系统（网络和SCSI）直接使用软中断。此外，内核定时器和tasklet都是建立在软中断上的。

如果同一个软中断在它被执行的同时再次被触发了，那么另外一个处理器可以同时运行其处理程序。这意味着任何共享数据（甚至是仅在中断处理程序内部使用的全局变量）都需要严格的锁保护。

ksoftirqd：

每个处理器都有一组辅助处理软中断和tasklet的内核线程。对于软中断，内核会选择在几个特殊时机进行处理。软中断被触发的频率有时可能很高，更不利的是，处理函数有时还会自行重复触发。

最终在内核中实现的方案是不会立即处理重新触发的软中断。而是当大量软中断出现的时候，内核会环形一组内核线程来处理这些负载。只要有待处理的软中断，ksoftirq就会调用do_softirq去处理它们。如果有必要的话，每次迭代后都会调用schedule以便让更重要的进程得到处理机会。

#### 6. 下半部：tasklet

tasklet是一种基于软中断实现的灵活性强、动态创建的下半部实现机制。两个不同类型的tasklet可以在不同的处理器上同时执行，但类型相同的tasklet不能同时执行。对于大部分下半部处理来说，用tasklet就足够了，像网络这样对性能要求非常高的情况才需要使用软中断。

#### 7. 下半部：工作队列

工作队列可以把工作推后，交由一个内核线程去执行，这个下半部总是会在进程上下文中执行。

缺省的工作者线程叫做events/n。缺省工作者线程会从多个地方得到被推后的工作。许多内核驱动程序都把它们的下半部交给缺省工作线程去做。

所有的工作者线程都是用普通内核线程实现的。在初始化完以后，这个函数执行一个死循环并开始休眠。当有操作被插入到队列的时候，线程就会被唤醒，以便执行这些操作。

大部分驱动程序都使用现存的默认工作者线程。在有些要求更严格的情况下，驱动程序需要自己的工作者线程。

尽管工作者的操作处理函数运行在进程上下文中，但它不能访问用户空间，因为内核线程在用户空间没有相关的内存映射。通常在发生系统调用时，内核会代表用户空间的进程运行，此时它才能访问用户空间，也只有在此时它才会映射用户空间的内存。

#### 8. 系统调用

通知内核的机制是靠软中断实现的：通过引发一个异常来促使系统切换到内核态去执行异常处理程序。此时的异常处理程序实际上就是系统调用处理程序。

在x86系统上预定义的软中断是中断号128，通过int 0x80指令触发该中断。这条指令会触发一个异常导致系统切换到内核态并执行第128号异常处理程序，而该程序正是系统调用处理程序system_call。

因为所有的系统调用陷入内核的方式都一样，都是调用system_call。因此必须把系统调用号一并传给内核。在x86上，系统调用号是通过eax寄存器传递给内核的。

#### 9. 定时器

系统定时器

周期性产生的事件比如每10ms一次，都是由系统定时器驱动的。系统定时器是一种可编程硬件芯片，它能以固定频率产生中断。该中断就是所谓的定时器中断，它所对应的中断处理程序负责更新系统时间，执行需要周期性运行的任务。

在x86体系结构中，主要采用可编程中断时钟PIT。内核在启动时对PIT进行编程初始化，使其能够以HZ/秒的频率产生时钟中断。

节拍率

节拍率：每秒钟定时器触发的次数，也就是赫兹HZ。它是通过静态预处理定义的，在系统启动时按照HZ值对硬件进行设置。

不要认为HZ值是一个固定不变的值。这不是一个常见的错误。大多数体系结构的节拍率都是可调的。

Linux内核支持“无节拍操作”这样的选项，当编译内核时设置了CONFIG_HZ选项，系统就可以在运行时动态调度时钟中断。

定时器

当前节拍计数等于或大于指定的超时时，内核就开始执行定时器处理函数。

内核在时钟中断发生后执行定时器，定时器作为软中断在下半部上下文中执行。具体来说，时钟中断处理程序会执行update_process_times函数，该函数随即调用run_local_timers函数。该函数处理软中断TIMER_SOFTIRQ，从而在当前处理器上运行所有的超时定时器。

### 第9-10章：内核同步

Linux内核是抢占式内核，调度程序可以在任何时刻抢占正在运行的内核代码，重新调度其它的进程执行。

各种锁机制之间的区别主要在于：一些锁被争用时会简单地执行忙等待，而另外一些锁会使当前任务睡眠知道锁可用为止。

在适用锁时，要知道需要保护的是数据而不是代码。

#### 1. 原子操作

大多数体系结构都会提供支持原子操作的简单算数指令。有些体系结构确实缺少简单的原子操作指令，但是也为单步执行提供了锁内存总线的指令，这就确保了其他改变内存的操作不能同时发生。

注：原子操作的本质是在访问变量时锁住内存总线，确保其它指令无法在同一时刻访问内存。内存总线式面向所有CPU的因此，原子操作对多核情况下都适用。

原子性确保指令执行期间不被打断，要么全部执行完，要么根本不执行。顺序性确保即使两条或多条指令出现在独立的执行线程中，甚至独立的处理器上，它们本该的执行顺序却依然要保持。

#### 2. 自旋锁

如果一个执行线程试图获得一个已被持有的自旋锁，那么该线程就会一直进行忙循环——旋转——等待锁重新可用。一个被争用的自旋锁使得请求它的线程在等待锁重新可用时自旋，这种行为就是自旋锁的要点。因此持有自旋锁的时间最好小于完成两次上下文切换的耗时。

#### 3. 信号量

信号量便提供了上述第二种锁机制，它使得在发生争用时，等待的线程能投入睡眠，而不是旋转。

#### 4. 顺序锁

当有疑义的数据被写入时，会得到一个锁，并且序列值会增加。在读取数据之前和之后，序列号都被读取。如果读取的序列号值相同，说明在读操作进行的过程中没有被写操作打断过。此外，如果读取的值是偶数，那么就表明写操作没有发生（要明白因为锁的初值是0，所以写锁会使值成奇数，释放的时候编程偶数）。

特点：读操作不加锁。

#### 5. 顺序和屏障

编译器会按照代码顺序进行编译，但处理器会重新动态排序，因为处理器在执行指令期间，会在取指令和分派时，把表面看似无关的指令按照自以为最好的顺序排列。CPU漏洞的根源就在于它可以强制改变指令的执行顺序。

#### 6. 中断、下半部和进程上下文的同步

自旋锁会禁止所有下半部的执行。

下半部和进程上下文：由于下半部可以抢占进程上下文，所以当下半部和进程上下文共享数据时，必须对进程上下文中的共享数据进行保护，所以需要加锁的同时还要禁止下半部执行。

中断和下半部：由于中断处理程序可以抢占下半部，所以如果中断处理程序和下半部共享数据，那么就必须下半部在获取恰当的锁的同时还要禁止中断。

tasklet：同类tasklet不可能同时运行，所以同类tasklet中的共享数据不需要保护，但不同类的两个tasklet共享数据时，需要在访问数据前申请一个自旋锁。

软中断：因为即使同种类型的两个软中断也可以同时在一个系统的多个处理器上，因此无论是否同种类型，如果数据被软中断共享，那么它必须得到锁的保护。同一处理器上的一个软中断绝不会抢占另一个软中断，因此根本没必要禁止下半部。

### 第12、15章：内存管理

#### 1. 页

内核把物理页作为内存管理的基本单位。MMU以页page大小为单位来管理系统中的页表。内核用struct page这一结构来管理系统中的所有页。如果页已经被分配，内核还需要知道谁拥有这个页，拥有者可能是用户空间进程、动态分配的内核数据、静态内核代码或页高速缓存等。

在x86体系结构上，ISA设备就不能在整个32位的地址空间中执行DMA，因为ISA设备只能访问物理内存的前16MB。在x86上，ZONE_NORMAL是从16MB到896MB的所有物理内存。在其他的体系结构上，ZONE_NORMAL是所有的可用物理内存。

#### 2. kmalloc和vmalloc

kmalloc函数确保页在物理地址上是连续的，vmalloc函数只 确保页在虚拟地址空间内是连续的。

#### 3. slab

为了便于数据的频繁分配和回收，常常会用到空闲链表。空闲链表包含可供使用的、已经分配好的数据结构块。当需要一个新的数据结构实例时，就可以从空闲链表种抓取一个，而不需要分配内存。当不再需要这个数据结构实例时，就把它放回空闲链表，而不是释放它。

slab层把不同的对象划分为所谓高速缓存组，其中每个高速缓存组都存放不同类型的对象。每种对象类型对应一个高速缓存。例如，一个高速缓存用于存放进程描述符，而另一个高速缓存粗放索引节点对象。有趣的是，kmalloc结构建立在slab层之上，使用了一组通用高速缓存。

#### 4. 进程地址空间

进程地址空间由进程可寻址的虚拟内存组成，每个进程都有一个32位或64位的平坦flat地址空间。尽管一个进程可以寻址4GB的虚拟内存（在32位的地址空间中），但这并不代表它就有权访问所有的虚拟地址。

进程只能访问有效内存区域内的内存地址。

内核使用内存描述符结构体mm_struct表示某个进程的地址空间，该结构包含了和进程地址空间有关的全部信息。结构体包含unsigned long类型的各种段的起始地址和结束地址，还有内存区域组成的链表和红黑树。

#### 5. mm_struct与内核线程

内核线程没有进程地址空间，也没有相关的内存描述符。所有内核线程对应的进程描述符中的mm域为空。事实上，这也正是内核线程的真实含义：它们没有用户上下文。

#### 6. 页表

Linux中使用三级页表完成地址转换。

虽然页表的工作由硬件执行，但是前提是内核必须正确地设置好页表，硬件才能从页表中进行查询。

### 第13-14、16-17章：磁盘与文件系统、页高速缓存

#### 1. 块设备与字符设备

系统中能够随机访问固定大小数据片的硬件设备称作块设备，这些固定大小的数据片就称作块。字符设备按照字符流的方式被有序访问，像串口和键盘就属于字符设备。它们的区别在于是否可以随机访问数据。

字符设备仅仅需要控制一个位置：当前位置，而块设备访问的位置必须能够在介质的不同区间前后移动。

#### 2. 扇区与块

块设备中最小的寻址单元是扇区，扇区大小是设备的物理属性，扇区是所有块设备的基本单元。块设备无法对比它还小的单元进行寻址和操作，尽管许多块设备能够一次对多个扇区进行操作。

操作系统最小的逻辑可寻址单元：块。只能基于块来访问文件系统。

扇区：设备的最小寻址单元，有时会称作硬扇区或设备块。

块：文件系统的最小寻址单元，有时会称作文件块或IO块。

#### 3. bio结构体

每一个块IO请求都通过一个bio结构体来表示。每个请求包含一个或多个块，这些块存储在bio_vec结构体数组中。这些结构体描述了每个片段在物理页中的实际位置，并且像向量一样被组织在一起。

#### 4. 四种IO调度程序

磁盘寻址是整个计算机中最慢的操作之一，每一次寻址（定位硬盘磁头到特定块上的某个位置）需要花费不少时间。IO调度程序通过两种方法减少磁盘寻址时间：合并与排序。

电梯调度：IO调度程序保证整个请求队列将按照扇区增长方向有序排列，通过保持磁头以直线方向移动，缩短了所有请求的磁盘寻址时间。

1、Linus电梯。2、最终期限IO调度程序。3、预测IO调度程序。4、完全公正的CFQIO调度程序。

CFQ调度程序以时间片轮转调度队列，从每个队列中选取请求数（默认为4），然后进行下一轮调度，这就在进程级别提供了公平，确保每个进程接收公平的磁盘带宽片段。

#### 5. 文件系统

Unix使用了四种和文件系统相关的传统抽象概念：文件、目录项、索引节点和安装节点。

在Unix中，目录属于普通文件，它列出包含在其中的所有文件。目录本质上可以理解为就是一个写入包含文件名的字符串文件而已。

Unix将文件的相关信息和文件本身这两个概念加以区分。文件相关信息，有时被称作文件的元数据，被存储在一个单独的数据结构中，该结构称作文件的元数据，被存储在一个单独的数据结构中，该结构被称为索引节点inode，它其实是index node。

文件系统的控制信息存储在超级块中，超级块是一种包含文件系统信息的数据结构。

#### 6. VFS

VFS中有四个主要的对象类型，它们分别是：超级块对象，索引节点对象，目录项对象，文件对象。

索引节点对象包含了内核在操作文件或目录时需要的全部信息。一个索引节点代表文件系统中的一个文件。索引节点仅当文件被访问时，才在内存中创建。

为了方便查找，VFS引入了目录项的概念，每个dentry代表路径中的一个特定部分。

文件对象表示进程已打开的文件，进程直接处理的是文件，而不是超级块、索引节点或目录项。文件对象是已打开文件在内存中的表示，该对象不是物理对象，由相应的open系统调用创建，由close系统调用撤销，所有这些文件相关的调用实际上都是文件操作表中定义的方法。

#### 7. 页高速缓存

页高速缓存是Linux内核实现的磁盘缓存，它主要用来减少对磁盘的IO操作。具体讲，是通过把磁盘中的数据缓存到物理内存中，把对磁盘的访问变为对物理内存的访问。

页高速缓存是由内存中的物理页面组成的，其内容对应磁盘上的物理块。内核开始读磁盘操作时，首先会检查需要的数据是否在页高速缓存中，如果在，则放弃访问磁盘，而直接从内存中读取。这个行为称作缓存命中。

写磁盘时的缓存策略：

写磁盘时，缓存一般被实现成下面三种策略之一：第一种策略称之为不缓存，高速缓存不缓存任何写操作。第二种策略是写操作自动更新内存缓存，同时页更新磁盘文件。第三种策略是回写，后端存储不会直接更新，将页高速缓存标记为脏，然后由一个进程周期性将脏页链表中的页写回到磁盘。

缓存回收：

Linux的缓存回收是通过选择干净页进行简单替换，最难的在于决定什么页应该回收，理想的回收策略应该改是回收那些以后最不可能使用的页面。

最近最少使用算法LRU：回收最老时间戳的页面；双链策略：维护两个链表，活跃和非活跃链表，只换出非活跃链表上的页。

#### 8. 统一设备模型

2.6内核增加了一个引人注目的新特性：统一设备模型。设备模型提供了一个独立的机制专门来表示设备，并描述其在系统中的拓扑结构。

sysfs文件系统是一个处于内存中的虚拟文件系统，它为我们提供了kobject对象层次结构的试图。

sysfs的根目录下包含了至少是个目录：block、bus、class、dev、devices、firmware、fs、kernel、module和power。block目录下的每个子目录都对应着系统中的一个已注册的块设备。bus目录提供了一个系统总线视图。class目录包含了以最高层功能逻辑组织起来的系统设备视图。dev目录是已注册设备节点的视图。devices目录是包含了以高层功能逻辑组织起来的系统设备视图。firmware目录包含了一些注入ACPI、EDD、EFI等低层次子系统的特殊树。fs目录是已注册文件系统的视图。kernel目录包含内核配置项和状态信息，module目录则包含已加载模块的信息。power目录包含系统范围的电源管理数据。

完。
