# 《Linux内核设计与实现》总结

## 0.写在前面

大约花了两周时间以每天30页的速度读完了这本书，这也是自己在业余时间第一本完整看完的、具有相当分量的专业书。

本书主要对Linux内核涉及的进程（进程管理、进程调度）、系统调用、中断（中断和中断处理、下半部和推后执行的工作）、内核同步、定时器和时间管理、内存（物理内存管理、进程地址空间）、磁盘（虚拟文件系统、块IO层）、页告诉缓存和页回写、设备和模块分别进行了详细的讲解。

收获：

通过本书，基本能够搞懂Linux内核的组成以及各个模块的实现过程。尤其是以前一点也不熟悉中断机制和下半部的内容，让自己对中断的理解有了质的飞跃。

疑惑：

由于对Linux启动过程的不熟悉，自己看完后一直有这样的疑惑：Linux加电启动后到底进行了哪些初始化动作、启动了哪些进程，CPU进程和中断处理持续又是怎么相互切换的？这一点感觉对整本书应该是提纲挈领的作用，可惜书中并没有具体描述。

后面如果知识储备到位的话，应该写一个《Linux内核导读手册》的专题，先把启动后的大致过程、进程和中断的切换、定时器和下半部的协作等内容串起来，然后再对内核的每个模块（进程、内存、中断、文件、网络）具体是如何实现的以及从低版本到高版本的发展过程做一个简单的梳理。

## 1. Linux内核简介

通常一个内核由负责响应中断的中断服务程序，负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序和网络、进程间通信等系统服务程序共同组成。

CPU在任一时刻只有两种状态：进程上下文（运行在用户空间或运行在内核空间）和中断上下文。当CPU空闲时，内核就运行一个idle空进程，处于进程上下文，运行在内核空间。

Linux是单内核，但支持动态加载内核模块，支持对称多处理SMP机制，支持抢占式。内核对抢占式、对称多处理器SMP、中断三者之间同步和并发的复杂处理。

内联函数和宏：

宏是由预处理器对宏进行简单的文本替换，而内联函数是在编译期间被嵌入到目标代码中。宏没有类型检查，可能传进来任意类型，在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。内联函数inline可以进行诸如类型安全检查、语句是否正确等编译功能，不会出现二义性。

## 2. 进程

进程提供两种虚拟机制，虚拟处理器和虚拟内存。对于Linux而言，线程只不过是一种特殊的进程。线程之间可以共享虚拟内存，但每个线程都拥有各自的虚拟处理器。

内核把进程存放在叫做任务队列的双向循环列表中，链表中的每一项都是类型为task_struct、称为进程描述符的结构体。Linux通过slab分配器分配task_struct结构，这样能达到对象复用和缓存着色的目的。

slab分配器：通过预先分配和重复使用task_struct，可以避免动态分配和释放所带来的资源消耗。

task_struct的存放位置：

如果是寄存器较多的CPU体系架构中，可能使用一个单独的寄存器来存放task_struct的地址。比如PowerPC架构中使用r2寄存器保存task_struct地址。但对于x86这种寄存器较少的体系架构来说，单独占用一个寄存器不合适，因此就把它放在了栈上。

在slab分配器机制出现之前的低版本Linux内核中，整个task_struct结构体都是和内核栈放在一起的，二者大致是这样定义的：

```
union {
    struct task_struct task;
    unsigned long stack[KERNEL_STACK_SIZE/sizeof (unsigned long)];
}
```

task_struct和内核栈共同使用了一段4kb或8kb的内存。更确切地说，内核根本不给task_struct分配内存，而仅仅给内核栈分配8K的内存，并把其中的一部分给task_struct使用。task_struct结构大约占1K字节左右（不同版本稍有不同），因此内核栈的大小不能超过7K，否则内核栈会覆盖task_struct结构，从而导致内核崩溃。

出现slab之后的高版本中，task_struct就通过slab分配器动态生成，指针存放于thread_info结构体的task变量，而thread_info就和内核栈共用内存了，定义是这样的：

```
union thread_union {
#ifndef CONFIG_THREAD_INFO_IN_TASK
    struct thread_info thread_info;
#endif
    unsigned long stack[THREAD_SIZE/sizeof(long)];
};
```

thread_info结构体的task指针指向了task_struct的位置。

```
struct thread_info {
    ......
    struct task_struct *task;    /* main task structure */
    ......
};
```

在x86系统上，通过把栈指针esp的最后13位有效位屏蔽掉，即可得到thread_info的偏移，然后就可以找到task_struct的地址了。
